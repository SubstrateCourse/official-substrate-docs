ref: https://docs.substrate.io/learn/runtime-development/

# Runtime development

如在架构中所讨论的，Substrate节点的运行时包含了执行交易、保存状态转换和与外部节点交互的所有业务逻辑。Substrate提供了构建常见区块链组件所需的所有工具，因此您可以专注于开发定义区块链行为的运行时逻辑。

## State transitions and the runtime

在最基本的层面上，每个区块链本质上都是一个账本或记录，记录了链上发生的每一次变化。在Substrate-based链中，这些状态变化被记录在运行时中。因为运行时处理这个操作，所以有时候会把运行时描述为提供状态转换函数。

因为状态转换发生在运行时，所以运行时是你定义代表区块链状态的存储项和允许区块链用户改变这个状态的交易的地方。


![](https://docs.substrate.io/static/6effe44b9d2d6811634d627228b41c48/154d5/state-transition-function.webp)

Substrate运行时决定哪些交易是有效的，哪些是无效的，以及如何根据交易改变链状态。

## Runtime interfaces

正如你在架构中学到的，外部节点负责处理节点发现、事务池、块和事务八卦、共识以及回答来自外部世界的RPC调用。这些任务经常需要外部节点查询运行时的信息或向运行时提供信息。运行时API促进了外部节点和运行时之间的这种通信。

在Substrate中，sp_api crate提供了一个实现运行时API的接口。它旨在让你有灵活性地使用impl_runtime_apis宏定义你自己的自定义接口。然而，每个运行时都必须实现Core和Metadata接口。除了这些必需的接口，大多数Substrate节点（如节点模板）实现了以下运行时接口：

- BlockBuilder用于构建块所需的功能。
- TaggedTransactionQueue用于验证交易。
- OffchainWorkerApi用于启用offchain操作。
- AuraApi用于使用一种轮询方法的共识进行区块作者和验证。
- SessionKeys用于生成和解码会话密钥。
- GrandpaApi用于将区块最终确定到运行时。
- AccountNonceApi用于查询交易索引。
- TransactionPaymentApi用于查询关于交易的信息。
- Benchmark用于估计和测量完成交易所需的执行时间。


## Core primitives

Substrate还定义了运行时必须实现的核心原语。Substrate框架对你的运行时必须提供给Substrate的其他层的内容做了最少的假设。然而，有一些数据类型必须被定义，并且必须满足一个特定的接口，才能在Substrate框架中工作。

这些核心原语是：

- Hash：一种编码某些数据的加密摘要的类型。通常只是一个256位的量。
- DigestItem：一种必须能够编码一些与共识和变更追踪相关的“硬编码”的备选项，以及与运行时中特定模块相关的任意数量的“软编码”的变体的类型。
- Digest：一系列DigestItems。这编码了轻客户端在区块中需要手头有的所有信息。
- Extrinsic：一种表示区块链外部的单个数据片段，并被区块链识别的类型。这通常涉及一个或多个签名，以及某种编码指令（例如，用于转移资金所有权或调用智能合约）。
- Header：一种代表与区块相关的所有信息（无论是加密方式还是其他方式）的类型。它包括父哈希、存储根和外部树根、摘要和区块编号。
- Block：本质上只是Header和一系列Extrinsics的组合，以及要使用的哈希算法的规范。
- BlockNumber：一种编码任何有效区块拥有的祖先总数的类型。通常是一个32位的量。


## FRAME

FRAME是你作为运行时开发者可用的最强大的工具之一。正如在Substrate赋予开发者中提到的，FRAME是Framework for Runtime Aggregation of Modularized Entities的缩写，它包含了大量的模块和支持库，简化了运行时开发。在Substrate中，这些模块——称为pallets——提供了可定制的业务逻辑，用于不同的用例和特性，你可以在你的运行时中包含它们。例如，有一些pallets提供了一个业务逻辑的框架，用于staking, consensus, governance等常见的活动。

关于可用的pallets的总结，请参见FRAME pallets。

除了pallets，FRAME还通过以下库和模块提供了与运行时交互的服务

- FRAME system crate frame_system为运行时提供了低级类型、存储和函数。
- FRAME support crate frame_support是一个Rust宏、类型、特征和模块的集合，简化了Substrate pallets的开发。
- FRAME executive pallet frame_executive协调了传入函数调用到运行时中相应pallets的执行。

下图说明了FRAME及其system, support, 和executives模块如何为运行时环境提供服务。

![](https://docs.substrate.io/static/26bc9a1dad7d0bb2198e86a5ee6dd885/18091/runtime-and-frame.webp)

### Composing a runtime with pallets

你可以在不使用FRAME的情况下构建一个基于Substrate的区块链。然而，FRAME pallets使你能够使用预定义的组件作为起点，组合定制运行时逻辑。每个pallet定义了特定的类型、存储项和函数，以实现运行时的一组特定特性或功能。

下图说明了你如何选择和组合FRAME pallets来组成一个运行时。


![](https://docs.substrate.io/static/64b2fcb61748ae77f4dd4c9ce63872b1/62cd2/compose-runtime.webp)


### Building custom pallets

除了预构建的FRAME pallets库外，你还可以使用FRAME库和服务来构建你自己的自定义pallets。通过自定义pallets，你可以灵活地定义最适合你目的的运行时行为。因为每个pallet都有自己的离散逻辑，你可以组合预构建的和自定义的pallets来控制你的区块链提供的特性和功能，以达到你想要的结果。

例如，你可能会在你的运行时中包含Balances pallet，以使用其与加密货币相关的存储项和函数来管理代币，但是添加自定义逻辑来在账户余额发生变化时调用你编写的pallet。

大多数pallets都是由以下部分的某种组合构成的：

- 导入和依赖
- Pallet类型声明
- 运行时配置特性
- 运行时存储
- 运行时事件
- 在特定上下文中应执行的逻辑的钩子
- 可以用来执行交易的函数调用

例如，如果你想定义一个自定义pallet，你可能会从一个类似于以下的pallet骨架结构开始：


```rust
// Add required imports and dependencies
pub use pallet::*;

#[frame_support::pallet]
pub mod pallet {
 use frame_support::pallet_prelude::*;
 use frame_system::pallet_prelude::*;

 // Declare the pallet type
 // This is a placeholder to implement traits and methods.
 #[pallet::pallet]
 #[pallet::generate_store(pub(super) trait Store)]
 pub struct Pallet<T>(_);

 // Add the runtime configuration trait
 // All types and constants go here.
 #[pallet::config]
 pub trait Config: frame_system::Config { ... }

 // Add runtime storage to declare storage items.
 #[pallet::storage]
 #[pallet::getter(fn something)]
 pub type MyStorage<T: Config> = StorageValue<_, u32>;

 // Add runtime events
 #[pallet::event]
 #[pallet::generate_deposit(pub(super) fn deposit_event)]
 pub enum Event<T: Config> { ... }

 // Add hooks to define some logic that should be executed
 // in a specific context, for example on_initialize.
 #[pallet::hooks]
 impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> { ... }

 // Add functions that are callable from outside the runtime.
 #[pallet::call]
 impl<T:Config> Pallet<T> { ... }
}
```

你可以根据需要，使用部分或全部的部分来组合pallets。当你开始设计和构建你的自定义运行时时，你将更多地了解FRAME库和用于定义配置特性、存储项、事件和错误的运行时原语，以及如何编写被分派到运行时执行的函数调用。

## Where to go next


现在你已经熟悉了Substrate运行时开发和使用pallets的基础知识，可以探索以下主题和教程以了解更多。

- Frame pallets
- 将模块添加到运行时
- 为Substrate准备的Rust
- 宏参考
- 在自定义pallet中使用宏





